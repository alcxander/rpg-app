import { NextResponse } from 'next/server'
import { auth } from '@clerk/nextjs/server'
import { createServerSupabaseClient } from '@/lib/supabaseAdmin'
import { rollLootTables, tableReferences, type LootItem } from '@/lib/loot/tables'
import { generateText } from 'ai'
import { openai } from '@ai-sdk/openai'

// Generate loot based on CR/party level and current battle if present.
// Uses simple tables first; if nothing suitable or an explicit fallback is needed, uses LLM. [^3]
export async function POST(req: Request) {
  const { userId, getToken } = await auth()
  if (!userId || !getToken) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
  const token = await getToken({ template: 'supabase' })
  if (!token) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })

  try {
    const supabase = createServerSupabaseClient(token)
    const { sessionId, battleId, cr, partyLevel, partyLoot, exactLevel } = await req.json()

    if (!sessionId) return NextResponse.json({ error: 'sessionId is required' }, { status: 400 })

    let effectiveCR: string | undefined = cr
    // If a battle is present, infer CR from monsters if available
    if (battleId) {
      const { data: battle } = await supabase.from('battles').select('*').eq('id', battleId).maybeSingle()
      if (battle && Array.isArray(battle.monsters)) {
        const crs = (battle.monsters as any[]).map((m) => Number(m?.cr)).filter((n) => !Number.isNaN(n))
        const avg = crs.length ? crs.reduce((a, b) => a + b, 0) / crs.length : undefined
        if (avg !== undefined) {
          if (avg < 1) effectiveCR = 'Easy'
          else if (avg < 3) effectiveCR = 'Medium'
          else if (avg < 7) effectiveCR = 'Hard'
          else effectiveCR = 'Deadly'
        }
      }
    }

    // Try tables first
    let loot: LootItem[] | null = null
    try {
      loot = rollLootTables({ cr: effectiveCR as any, partyLevel: partyLevel ? Number(partyLevel) : undefined, partyLoot: !!partyLoot, exactLevel: !!exactLevel })
    } catch {
      loot = null
    }

    if (loot && loot.length) {
      return NextResponse.json({ source: 'tables', references: tableReferences, loot })
    }

    // Fallback to LLM [^3]
    const { text } = await generateText({
      model: openai('gpt-4o'),
      system: 'You create balanced treasure hoards for TTRPG encounters.',
      prompt: `Create a JSON array of loot appropriate for an encounter.
Context:
- Difficulty: ${effectiveCR || cr || 'Medium'}
- Party level: ${partyLevel || 3}
- Party loot: ${partyLoot ? 'Yes' : 'No'}
- Include coins, trinkets, gear/weapons, and consumables. Scale rarity with difficulty.
- JSON only. Each item has: { "type": "coin|trinket|gear|consumable", "name"?: string, "amount"?: number, "currency"?: "cp|sp|gp|pp", "rarity"?: "Common|Uncommon|Rare|Very Rare|Legendary" }`,
    })
    let cleaned = text.trim()
    if (cleaned.startsWith('```json')) cleaned = cleaned.slice('```json'.length)
    if (cleaned.endsWith('```')) cleaned = cleaned.slice(0, -3)
    const parsed = JSON.parse(cleaned)
    return NextResponse.json({ source: 'llm', loot: parsed, note: 'Generated by AI SDK fallback.' })
  } catch (e: any) {
    return NextResponse.json({ error: e.message || 'Failed to generate loot' }, { status: 500 })
  }
}
